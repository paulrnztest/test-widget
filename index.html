<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BRAVO â€” Agent Assist (PoC)</title>

  <!-- LivePerson Agent Workspace Widget SDK -->
  <script src="https://lpcdn.lpsnmedia.net/webagent/client-SDK.min.js"></script>

  <style>
    body {
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin:16px;
    }

    h3 { margin: 0 0 4px 0; }
    h4 { margin-top: 16px; }
    ul { margin: 6px 0 0 18px; }

    button { padding: 6px 10px; cursor:pointer; }

    textarea {
      width:100%;
      box-sizing:border-box;
      resize: vertical;
    }

    .badge {
      background:#e8e8e8;
      padding:3px 6px;
      border-radius:6px;
      font-size:11px;
    }

    .muted {
      color:#666;
      font-size:12px;
    }

    #msgs {
      white-space: pre-wrap;
      border:1px solid #ddd;
      padding:8px;
      background:#fafafa;
      max-height:180px;
      overflow:auto;
      margin-top:6px;
      font-size:13px;
    }

    .assist {
      background:#f7f9fc;
      padding:10px;
      border-left:3px solid #6b8cff;
      margin-top:14px;
    }

    #timestamp {
      margin-left:8px;
    }
  </style>
</head>

<body>

  <h3>BRAVO â€” Agent Assist <span class="badge">preview 1.0.12</span></h3>
  <div class="muted">
    Realâ€‘time guidance based on the current conversation.
    Review before sending â€” youâ€™re always in control.
  </div>

  <div style="margin: 8px 0;">
    Conversation: <b id="convId">(no active conversation)</b>
  </div>

  <div style="margin:10px 0;">
    <button id="btnRefresh">ðŸ”„ Refresh suggestions</button>
    <button id="btnInsert" disabled>Insert suggested reply</button>
    <span id="timestamp" class="muted"></span>
  </div>

  <!-- EMPTY / IDLE STATE -->
  <div id="emptyState" class="assist muted" style="display:none;">
    <b>Waiting for an active conversation</b>
    <div style="margin-top:6px;">
      When you accept a conversation, BRAVO will surface guidance
      and suggested replies here.
    </div>
  </div>

  <!-- ASSIST CONTENT -->
  <div class="assist" id="assistContent">
    <h4>Things to keep in mind</h4>
    <ul>
      <li>
        Top-up / payment channels <b>recently had a known issue affecting some self-service top-ups and payments</b>; advisors should be aware this may explain unexpected behaviour, but <b>the issue is now resolved and BAU applies</b>.
      </li>
      <li>
        Refund or credit decisions must follow <b>standard (BAU) refund/billing processes</b>, as there is <b>no special exception process documented here for duplicate top-up packs</b>.
      </li>
    </ul>

    <h4>What to check next</h4>
    <ul>
      <li>
        Check the customerâ€™s recent top-up history and pack activations to confirm whether two identical packs were purchased and successfully applied, and if this coincides with the reported self-service issue window.
      </li>
      <li>
        Follow BAU refund/credit assessment and processing for mobile/prepaid where applicable, documenting the situation clearly (double charge, no intent to buy two packs) and whether any system error is suspected.
      </li>
    </ul>

    <h4>Suggested reply <span class="muted">(editable)</span></h4>
    <textarea id="suggestedReply" rows="4" readonly>
      Thanks for letting us know whatâ€™s happened, that does sound frustrating.
      Iâ€™ll first take a look at your recent top-ups to confirm what was charged and which packs have actually been applied. Once I can see exactly whatâ€™s gone through, Iâ€™ll review whether we can reverse or credit one of those pack purchases for you and talk you through the options.
      Iâ€™ll come back to you shortly with what I find and what we can do next.
    </textarea>
  </div>

  <!-- CONVERSATION CONTEXT -->
  <h4>Latest customer messages</h4>
  <div id="msgs"></div>

<script>
/* -------------------------------------------------------
   Agent SDK init
------------------------------------------------------- */
async function waitForAgentSDK(ms = 8000) {
  const t0 = Date.now();
  while (Date.now() - t0 < ms) {
    if (window.lpTag?.agentSDK) return;
    await new Promise(r => setTimeout(r, 100));
  }
  throw new Error("Agent SDK not found in iframe.");
}

let _inited = false;
async function ensureAgentSDK() {
  if (_inited) return;
  await waitForAgentSDK();
  window.lpTag.agentSDK.init({});
  _inited = true;
  console.log("[LP] agentSDK initialised");
}

/* -------------------------------------------------------
   Oneâ€‘shot bind helper
------------------------------------------------------- */
function bindOnce(path) {
  return new Promise((resolve) => {
    const cb = (data) => {
      try { window.lpTag.agentSDK.unbind(path, cb); } catch {}
      resolve(data);
    };
    window.lpTag.agentSDK.bind(path, cb, () => resolve(null));
  });
}

/* -------------------------------------------------------
   Context helpers
------------------------------------------------------- */
async function getConversationIdFromTranscript() {
  const payload = await bindOnce("chatTranscript.lines");
  const lines = payload?.newValue || [];
  const latest = lines.length ? lines[lines.length - 1] : null;
  return latest?.dialogId || "";
}

async function fetchTranscriptSlice(limit = 8) {
  const payload = await bindOnce("chatTranscript.lines");
  const lines = payload?.newValue || [];

  return Array.isArray(lines)
    ? lines.slice(-limit).map(line => {
        const s = (line.source || line.by || "").toLowerCase();

        // Explicit role detection
        const isCustomer =
          s.includes("consumer") ||
          s.includes("visitor") ||
          s.includes("customer");

        const isAgent = s.includes("agent");
        const isBot = s.includes("bot");

        // Ignore system / controller / manager messages
        if (!isCustomer && !isAgent && !isBot) {
          return null;
        }

        return {
          from: isCustomer ? "customer" : isBot ? "bot" : "agent",
          text: line.text || line.message || "",
          dialogId: line.dialogId || ""
        };
      }).filter(Boolean) // remove null (system) lines
    : [];
}

/* -------------------------------------------------------
   Insert suggested reply (populate composer)
------------------------------------------------------- */
async function insertIntoComposer(text) {
  await ensureAgentSDK();

  const sdk = window.lpTag.agentSDK;
  const cmdNames = sdk.cmdNames || {};
  const payload = { text: (text || "").trim() };

  if (!payload.text) return;

  const tryCmd = (cmdName) => new Promise((resolve) => {
    sdk.command(
      cmdName,
      payload,
      () => { console.log("[BRAVO] Insert OK via", cmdName); resolve(true); },
      (e) => { console.warn("[BRAVO] Insert FAIL via", cmdName, e); resolve(false); }
    );
  });

  // 1) Preferred: write (most common insert-to-input behavior)
  if (cmdNames.write) {
    const ok = await tryCmd(cmdNames.write);
    if (ok) return;
  }

  // 2) Fallback: writeSC (secure channel)
  if (cmdNames.writeSC) {
    const ok = await tryCmd(cmdNames.writeSC);
    if (ok) return;
  }

  // If neither exists, warn
  console.warn("[BRAVO] No supported insert command found. cmdNames:", cmdNames);
}

/* -------------------------------------------------------
   Timestamp helper
------------------------------------------------------- */
function updateTimestamp() {
  const el = document.getElementById("timestamp");
  const now = new Date();
  el.textContent = `Last updated ${now.toLocaleTimeString()}`;
}

/* -------------------------------------------------------
   State + render
------------------------------------------------------- */
const state = { convId: "", messages: [] };
const $ = (sel) => document.querySelector(sel);

function render() {
  const hasConversation = Boolean(state.convId);

  $("#convId").textContent =
    hasConversation ? state.convId : "(no active conversation)";

  $("#emptyState").style.display = hasConversation ? "none" : "block";
  $("#assistContent").style.display = hasConversation ? "block" : "none";

  const msgBox = $("#msgs");
  msgBox.textContent = "";

  if (hasConversation) {
    state.messages
      .filter(m => m.from === "customer")
      .forEach(m => {
        msgBox.textContent += `ðŸ§‘ ${m.text}\n`;
      });
  }

  $("#btnInsert").disabled =
    !hasConversation || !$("#suggestedReply").value.trim();
}

/* -------------------------------------------------------
   Manual refresh
------------------------------------------------------- */
async function refreshContext() {
  try {
    await ensureAgentSDK();
    state.convId = await getConversationIdFromTranscript();
    state.messages = await fetchTranscriptSlice(8);
    updateTimestamp();
    render();
  } catch (e) {
    console.error("refreshContext failed:", e);
  }
}

/* -------------------------------------------------------
   Autoâ€‘connect once on first conversation
------------------------------------------------------- */
let _autoConnected = false;

async function attachAutoConnectListener() {
  await ensureAgentSDK();

  const handler = (data) => {
    if (_autoConnected) return;

    const lines = data?.newValue || [];
    const latest = lines.length ? lines[lines.length - 1] : null;

    if (latest?.dialogId) {
      _autoConnected = true;
      refreshContext();
      try { window.lpTag.agentSDK.unbind("chatTranscript.lines", handler); } catch {}
    }
  };

  window.lpTag.agentSDK.bind("chatTranscript.lines", handler, () => {});
}

attachAutoConnectListener();

/* -------------------------------------------------------
   Wire up
------------------------------------------------------- */
$("#btnRefresh").addEventListener("click", refreshContext);
$("#btnInsert").addEventListener("click", () =>
  insertIntoComposer($("#suggestedReply").value)
);

// Initial render (idle)
render();
</script>

</body>
</html>


