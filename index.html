<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BRAVO (PoC) — Placeholder Widget</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: "Segoe UI", system-ui, Arial, sans-serif; }
    body { margin: 0; padding: 12px; }
    button { padding: 6px 10px; cursor: pointer; }
    textarea { width: 100%; box-sizing: border-box; }
    h3 { margin: 0 0 8px 0; }
    h4 { margin-top: 16px; }
    ul { margin: 6px 0 0 18px; }
    .badge { background: #e8e8e8; padding: 3px 6px; border-radius: 6px; font-size: 11px; }
  </style>
</head>

<body>
  
  <div id="sdkStatus" style="font:12px Segoe UI, Arial; color:#444; background:#f6f6f6; padding:6px 8px; margin:0 0 8px 0; border-radius:6px;">
    Checking LivePerson SDK…
  </div>

  <h3>BRAVO (PoC) <span class="badge">mock data</span></h3>

  <div style="margin: 8px 0;">
    Conversation: <b id="convId">(loading…)</b>
  </div>

  <div style="margin: 10px 0;">
    <button id="btnRefresh">Refresh Context</button>
    <button id="btnInsert" disabled>Insert Suggested Reply</button>
  </div>

  <!-- Placeholder Panels -->
  <h4>Relevant Information</h4>
  <ul id="relevantInfo">
    <li>A higher bill after a recent plan change is often due to a <b>transition bill</b> where customers can see pro‑rated charges from the old plan and new plan on the same bill.</li>
    <li>A <b>Bill Estimator</b> tool is available internally to help estimate charges when customers change broadband plans.</li>
  </ul>

  <h4>Suggested Next Steps</h4>
  <ul id="nextSteps">
    <li>Check in Spark CRM what plan the customer was on, what plan they moved to, and the <b>effective date of the change.</b></li>
    <li>Compare the last bill and the current bill to identify <b>pro‑rated old plan charges/credits</b> and the <b>new plan charges</b>.</li>
  </ul>

  <h4>Suggested Reply</h4>
  <textarea id="suggestedReply" rows="4" readonly>
Thanks for letting me know you’ve changed plans – that’s really helpful. When a plan changes, the first bill afterwards can look higher because it can include part of your old plan, part of your new plan, and any credits or adjustments for the changeover. I’ll pull up your last bill and this month’s bill now and break down exactly what’s different so you can see what’s one‑off for the change and what your regular monthly cost will be going forward.
  </textarea>

  <!-- Latest Messages -->
  <h4>Latest Messages</h4>
  <ul id="msgs"></ul>
  <small>(TODO - Replace stubbed functions with LP Widget SDK to fetch real messages)</small>

<script>

  // =======================================================
  //  DEBUG
  // =======================================================

  (function () {
    const $ = (sel) => document.querySelector(sel);
    const statusEl = $("#sdkStatus");
  
    function readStatus() {
      if (window.LPWidget) return 'Widgets SDK';
      if (window.lpTag && window.lpTag.agentSDK) return 'Agent SDK';
      return 'No SDK detected';
    }
  
    function updateStatus(note) {
      const mode = readStatus();
      statusEl.textContent = `[${mode}] ${note || ''}`.trim();
    }
  
    // Initial ping
    updateStatus('Waiting for injection…');
    // Update every 500ms for a few seconds so you can see it flip when injected
    let ticks = 0;
    const t = setInterval(() => {
      updateStatus('Waiting for injection…');
      if (readStatus() !== 'No SDK detected' || ++ticks > 20) clearInterval(t);
    }, 500);
  })();

  // =======================================================
  //  STUBS — Replace with LivePerson Widget SDK later
  // =======================================================

  
  async function waitForLPsdk(timeoutMs = 8000) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      if (window.LPWidget || (window.lpTag && window.lpTag.agentSDK)) return;
      await new Promise(r => setTimeout(r, 150));
    }
    throw new Error('LivePerson SDK not available in this iframe. Is the widget loaded in Agent Workspace?');
  }
  
  // Unified helpers
  async function getActiveConversationId() {
    await waitForLPsdk();
    if (window.LPWidget) {
      return await window.LPWidget.context.activeConversationId();
    }
    if (window.lpTag && window.lpTag.agentSDK) {
      // Agent SDK flow
      window.lpTag.agentSDK.init?.({});
      // Try conversationInfo → get or subscribe once
      const getOnce = (path) => new Promise(res => {
        window.lpTag.agentSDK.get(path, d => res(d), () => res(null));
      });
      const info = await getOnce('conversationInfo');
      if (info?.conversationId || info?.conversationID) {
        return info.conversationId || info.conversationID;
      }
      return await new Promise(res => {
        const handler = (d) => { try { window.lpTag.agentSDK.unsubscribe('conversationInfo', handler); } catch(e){}; res(d?.conversationId || d?.conversationID || ''); };
        window.lpTag.agentSDK.subscribe('conversationInfo', handler, () => res(''));
      });
    }
    throw new Error('No SDK detected');
  }
  
  async function fetchTranscript(conversationId, limit = 30) {
    await waitForLPsdk();
    if (window.LPWidget) {
      return await window.LPWidget.api.getMessages({ conversationId, limit });
    }
    if (window.lpTag && window.lpTag.agentSDK) {
      window.lpTag.agentSDK.init?.({});
      const tryPath = async (p) => new Promise(res => {
        window.lpTag.agentSDK.get(p, d => res(d), () => res(null));
      });
      const data = (await tryPath('conversationTranscript.lines')) || (await tryPath('chatTranscript.lines'));
      if (Array.isArray(data)) {
        return data.slice(-limit).map(line => ({
          from: (line.source || line.by || '').toString().toLowerCase().includes('agent') ? 'agent'
              : (line.source || line.by || '').toString().toLowerCase().includes('bot')   ? 'bot'
              : 'customer',
          text: line.text || line.message || ''
        }));
      }
      return [];
    }
    return [];
  }
  
  async function insertIntoComposer(text) {
    await waitForLPsdk();
    const convId = await getActiveConversationId();
    if (window.LPWidget) {
      return window.LPWidget.api.setComposerText({ conversationId: convId, text });
    }
    if (window.lpTag && window.lpTag.agentSDK) {
      window.lpTag.agentSDK.init?.({});
      const cmd = (name) => new Promise(r => window.lpTag.agentSDK.command(name, { text }, () => r(true), () => r(false)));
      if (await cmd('SendText')) return;
      await cmd('Write ChatLine');
    }
  }


  // =======================================================
  //  SIMPLE STATE + RENDER
  // =======================================================

  const state = { convId: "", messages: [] };
  const $ = (sel) => document.querySelector(sel);

  function render() {
    // show conversation ID
    $("#convId").textContent = state.convId || "(none)";

    // latest messages list
    const msgList = $("#msgs");
    msgList.innerHTML = "";
    state.messages.forEach(m => {
      const li = document.createElement("li");
      li.innerHTML = `<b>${m.from}:</b> ${m.text}`;
      msgList.appendChild(li);
    });

    // suggested reply (placeholder)
    const replyText = $("#suggestedReply").value.trim();
    $("#btnInsert").disabled = !replyText;
  }

  async function refreshContext() {
    state.convId = await getActiveConversationId();
    state.messages = await fetchTranscript(state.convId, 5);
    render();
  }

  $("#btnRefresh").addEventListener("click", refreshContext);
  $("#btnInsert").addEventListener("click", () => {
    insertIntoComposer($("#suggestedReply").value);
  });

  // Load immediately
  refreshContext();
</script>
</body>
</html>





